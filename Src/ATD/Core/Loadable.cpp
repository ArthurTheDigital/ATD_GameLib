/**
 * TODO: Add hat. */

#include <ATD/Core/Loadable.hpp>

#include <ATD/Core/Printf.hpp>

#include <set>
#include <stdexcept>


/* ATD::Loadable: */

/* 'm_hasChanged' bit must be initially set true, because if Loadable was 
 * generated by program, it should be written to disk when required. And 
 * 'm_hasChanged == false' prevents writing it to disk. */

ATD::Loadable::Loadable()
	: m_dependencyTable()
	, m_hasChanged(true)
{}

ATD::Loadable::~Loadable()
{}

void ATD::Loadable::load(const ATD::Fs::Path &filename)
{
	/* Load the Loadable itself. */
	onLoad(filename);

	/* Check the dependency table. */
	checkDependencyTable();

	/* Recursively load all the dependencies. */
	for (auto &depPair : m_dependencyTable) {
		depPair.first->load(*depPair.second);
	}

	onLoadFinished();

	/* Nullify the 'm_hasChanged' bit. */
	m_hasChanged = false;
}

void ATD::Loadable::save(const ATD::Fs::Path &filename) const
{
	/* Save the Loadable itself if required. */
	if (m_hasChanged) {
		onSave(filename);
	}

	/* Check the dependency table. */
	checkDependencyTable();

	/* Recursively load all the dependencies. */
	for (auto &depPair : m_dependencyTable) {
		depPair.first->save(*depPair.second);
	}

	onSaveFinished();

	/* Nullify the 'm_hasChanged' bit. */
	m_hasChanged = false;
}

const ATD::Loadable::DependencyTable &
	ATD::Loadable::getDependencyTable() const
{
	return m_dependencyTable;
}

void ATD::Loadable::addDependency(ATD::Loadable *dependency)
{
	m_dependencyTable.insert(
			std::pair<Loadable *, std::shared_ptr<Fs::Path>>(
				dependency, 
				nullptr));
}

void ATD::Loadable::setDependencyPath(ATD::Loadable *dependency, 
		const ATD::Fs::Path &filename)
{
	m_dependencyTable.at(dependency) = 
		std::shared_ptr<Fs::Path>(
				new Fs::Path(filename));
}

const ATD::Fs::Path &ATD::Loadable::getDependencyPath(
		ATD::Loadable *dependency) const
{
	auto dependencyPathPtr = m_dependencyTable.at(dependency);
	if (!dependencyPathPtr) {
		throw std::runtime_error("Attempt to obtain unresolved dependency");
	}
	return *dependencyPathPtr;
}

void ATD::Loadable::setChanged()
{
	m_hasChanged = true;
}

void ATD::Loadable::onLoadFinished()
{}

void ATD::Loadable::onSaveFinished() const
{}

void ATD::Loadable::checkDependencyTable() const
{
	std::set<Loadable *> faultDependencies;
	for (auto &depPair : m_dependencyTable) {
		if (!depPair.second) {
			faultDependencies.insert(depPair.first);
		}
	}
	if (faultDependencies.size()) {
		std::string faultDependenciesStr;
		for (auto &faultDep : faultDependencies) {
			if (!faultDependenciesStr.size()) {
				faultDependenciesStr = Aux::printf("%p", faultDep);
			} else {
				faultDependenciesStr += Aux::printf(", %p", faultDep);
			}
		}
		throw std::runtime_error(
				Aux::printf(
					"Unresolved dependencies: [%s]", 
					faultDependenciesStr.c_str()));
	}
}


